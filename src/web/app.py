"""
PondMonitor Flask Application - Refactored Version

Migrated to use modular services for better maintainability and testability.
Generated by migrate_app.py on 2025-08-18T17:11:30.557796

Week 1 Refactoring Changes:
✅ Centralized configuration management
✅ Database service abstraction with connection pooling
✅ Enhanced error handling and validation
✅ Improved export service with multiple formats
✅ Weather service with intelligent caching
✅ Structured logging with request tracking
✅ Comprehensive unit tests

Original functionality preserved with improved architecture.
"""

import os
import json
import logging
from datetime import datetime, timezone, timedelta
from flask import Flask, render_template, request, jsonify, g
from collections import defaultdict
from typing import Optional, Dict, Any, List

# Import our new modular services (using relative imports)
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from src.config import init_config, get_config
from src.database import init_database, get_database
from src.utils import handle_errors, log_requests, validate_json, Validator
from src.services.export_service import create_export_service, ExportConfig
from src.services.weather_service import create_weather_service
from src.logging_config import setup_logging, get_logger, PerformanceLogger

# Initialize logger
logger = get_logger(__name__)

# Global service instances
db_service = None
export_service = None
weather_service = None


def create_app(config_file: str = ".env") -> Flask:
    """
    Application factory with dependency injection.
    
    Args:
        config_file: Path to configuration file
    
    Returns:
        Configured Flask application
    """
    global db_service, export_service, weather_service
    
    # Initialize configuration
    logger.info("Initializing PondMonitor application")
    config = init_config(config_file)
    
    # Setup logging
    setup_logging(
        config.logging, 
        environment=config.flask.environment,
        enable_request_tracking=True
    )
    
    # Initialize Flask app
    app = Flask(__name__)
    app.config.update({
        'SECRET_KEY': config.flask.secret_key,
        'TESTING': config.flask.testing,
        'DEBUG': config.flask.debug
    })
    
    # Initialize services
    logger.info("Initializing services")
    
    try:
        # Database service
        db_service = init_database(config.database)
        logger.info("✅ Database service initialized")
        
        # Export service
        export_service = create_export_service(db_service)
        logger.info("✅ Export service initialized")
        
        # Weather service
        weather_service = create_weather_service(config.weather, config.redis)
        logger.info("✅ Weather service initialized")
        
    except Exception as e:
        logger.error(f"Failed to initialize services: {e}")
        raise
    
    # Register error handlers
    register_error_handlers(app)
    
    # Register routes
    register_routes(app)
    
    logger.info("PondMonitor application initialized successfully")
    return app


def register_error_handlers(app: Flask) -> None:
    """Register global error handlers"""
    
    @app.errorhandler(500)
    def internal_server_error(error):
        logger.error(f"Internal server error: {error}")
        return jsonify({"error": "Internal server error"}), 500

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({"error": "Resource not found"}), 404


def register_routes(app: Flask) -> None:
    """Register all application routes"""
    
    # =================================================================
    # PAGE ROUTES (unchanged from original)
    # =================================================================
    
    @app.route("/")
    def dashboard():
        return render_template("dashboard.html")

    @app.route("/weather")
    def weather():
        return render_template("weather.html")

    @app.route("/diagnostics")
    def diagnostics():
        return render_template("diagnostics.html")
    
    # =================================================================
    # API ROUTES (enhanced with new services)
    # =================================================================
    
    @app.route("/health")
    @log_requests
    @handle_errors
    def health_check():
        """Enhanced health check with service status"""
        
        with PerformanceLogger(logger, "health_check"):
            status = {
                "status": "healthy",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "services": {}
            }
            
            # Check database service
            try:
                db_health = db_service.health_check()
                status["services"]["database"] = "healthy" if db_health.get("healthy") else "unhealthy"
            except Exception as e:
                logger.warning(f"Database health check failed: {e}")
                status["services"]["database"] = "unhealthy"
            
            # Check weather service
            try:
                weather_health = weather_service.health_check()
                status["services"]["weather_api"] = "healthy" if weather_health.get("healthy") else "degraded"
            except Exception as e:
                logger.warning(f"Weather health check failed: {e}")
                status["services"]["weather_api"] = "unhealthy"
            
            # Overall status
            unhealthy_services = [
                k for k, v in status["services"].items() 
                if v not in ["healthy", "degraded"]
            ]
            
            if unhealthy_services:
                status["status"] = "degraded"
                status["unhealthy_services"] = unhealthy_services
            
            return jsonify(status)
    
    @app.route("/api/status")
    @log_requests
    @handle_errors
    def get_status():
        """Get current sensor status from database"""
        
        with PerformanceLogger(logger, "get_status"):
            # Get latest metrics from database
            latest_metrics = db_service.get_latest_metrics()
            
            if not latest_metrics:
                return jsonify({"error": "No data available"}), 404
            
            # Calculate connection status
            now = datetime.now(timezone.utc)
            if 'station_timestamp' in latest_metrics:
                last_seen = latest_metrics['station_timestamp']
                if isinstance(last_seen, str):
                    last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00'))
                
                delta = now - last_seen
                connected = delta.total_seconds() < 120
                last_seen_minutes = int(delta.total_seconds() / 60)
            else:
                connected = False
                last_seen_minutes = 999
            
            # Build response
            response_data = {
                "connected": connected,
                "last_seen_minutes": last_seen_minutes,
                "last_heartbeat": latest_metrics.get('station_timestamp', now.isoformat()),
                "temperature_c": latest_metrics.get('temperature_c'),
                "battery_v": latest_metrics.get('battery_v'),
                "solar_v": latest_metrics.get('solar_v'),
                "signal_dbm": latest_metrics.get('signal_dbm'),
                "on_solar": (latest_metrics.get('solar_v') or 0) > 1.0,
                "device_id": "POND-001",
                "firmware_version": "1.0.0"
            }
            
            return jsonify(response_data)
    
    @app.route("/api/dashboard")
    @log_requests
    @handle_errors
    def api_dashboard():
        """Get dashboard data with enhanced validation"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({"error": "Missing start or end parameter"}), 400
        
        try:
            # Validate datetime range using new validator
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            with PerformanceLogger(logger, "dashboard_data_query", 
                                 start=start, end=end):
                
                # Get pond metrics
                pond_data = db_service.get_pond_metrics(start_dt, end_dt)
                
                # Transform to expected format (timestamp in milliseconds, value)
                level_data = []
                outflow_data = []
                
                for record in pond_data:
                    timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                    
                    if record['level_cm'] is not None:
                        level_data.append([timestamp_ms, record['level_cm']])
                    
                    if record['outflow_lps'] is not None:
                        outflow_data.append([timestamp_ms, record['outflow_lps']])
                
                return jsonify({
                    "level": level_data,
                    "outflow": outflow_data,
                    "data_points": len(pond_data)
                })
                
        except Exception as e:
            logger.error(f"Dashboard API error: {e}", exc_info=True)
            raise
    
    @app.route("/api/lora")
    @log_requests
    @handle_errors
    def diagnostics_data():
        """Get LoRa diagnostics data"""
        
        hours = request.args.get("hours", 24, type=int)
        
        # Validate hours parameter
        if not 1 <= hours <= 168:  # 1 hour to 1 week
            return jsonify({"error": "Hours must be between 1 and 168"}), 400
        
        start_time = datetime.now(timezone.utc) - timedelta(hours=hours)
        end_time = datetime.now(timezone.utc)
        
        with PerformanceLogger(logger, "lora_diagnostics_query", hours=hours):
            
            # Get station metrics
            station_data = db_service.get_station_metrics(start_time, end_time)
            
            # Transform to expected format
            temperature = []
            battery_voltage = []
            solar_voltage = []
            signal_strength = []
            
            for record in station_data:
                timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                
                if record['temperature_c'] is not None:
                    temperature.append([timestamp_ms, round(record['temperature_c'], 1)])
                
                if record['battery_v'] is not None:
                    battery_voltage.append([timestamp_ms, round(record['battery_v'], 2)])
                
                if record['solar_v'] is not None:
                    solar_voltage.append([timestamp_ms, round(record['solar_v'], 2)])
                
                if record['signal_dbm'] is not None:
                    signal_strength.append([timestamp_ms, record['signal_dbm']])
            
            return jsonify({
                "temperature": temperature,
                "battery_voltage": battery_voltage,
                "solar_voltage": solar_voltage,
                "signal_strength": signal_strength,
                "data_points": len(station_data),
                "time_range_hours": hours
            })
    
    # =================================================================
    # WEATHER API ROUTES (using new weather service)
    # =================================================================
    
    @app.route("/api/weather/current")
    @log_requests
    @handle_errors
    def weather_current():
        """Get current weather conditions"""
        
        with PerformanceLogger(logger, "weather_current"):
            current_weather = weather_service.get_current_weather()
            
            if not current_weather:
                return jsonify({"error": "Weather service unavailable"}), 503
            
            # Transform to expected format
            response = {
                "timestamp": current_weather.timestamp,
                "temperature": current_weather.temperature,
                "pressure": current_weather.pressure,
                "humidity": current_weather.humidity,
                "wind": current_weather.wind_speed,
                "wind_direction": current_weather.wind_direction,
                "wind_gust": current_weather.wind_gust,
                "cloud_coverage": current_weather.cloud_coverage,
                "rain": current_weather.precipitation,
                "symbol_code": current_weather.symbol_code
            }
            
            return jsonify(response)
    
    @app.route("/api/weather/meteogram")
    @log_requests
    @handle_errors
    def weather_meteogram():
        """Get 48-hour detailed forecast for meteogram"""
        
        with PerformanceLogger(logger, "weather_meteogram"):
            meteogram_data = weather_service.get_meteogram_data(48)
            
            # Transform to expected format
            result = []
            for weather in meteogram_data:
                weather_point = {
                    "time": int(datetime.fromisoformat(weather.timestamp.replace("Z", "+00:00")).timestamp() * 1000),
                    "temperature": weather.temperature,
                    "rain": weather.precipitation,
                    "wind": weather.wind_speed,
                    "wind_direction": weather.wind_direction,
                    "wind_gust": weather.wind_gust,
                    "pressure": weather.pressure,
                    "humidity": weather.humidity,
                    "cloud": weather.cloud_coverage,
                    "symbol_code": weather.symbol_code
                }
                result.append(weather_point)
            
            return jsonify(result)
    
    @app.route("/api/weather/daily")
    @log_requests
    @handle_errors
    def daily_forecast():
        """Get 7-day daily forecast summary"""
        
        with PerformanceLogger(logger, "weather_daily"):
            daily_data = weather_service.get_daily_forecast(7)
            
            # Transform to expected format
            result = []
            for day in daily_data:
                daily_summary = {
                    "date": day.date,
                    "temp": day.temp_max,
                    "temp_min": day.temp_min,
                    "temp_avg": day.temp_avg,
                    "wind_avg": day.wind_avg,
                    "wind_gust": day.wind_gust,
                    "rain": day.precipitation,
                    "humidity_avg": day.humidity_avg,
                    "pressure_avg": day.pressure_avg,
                    "icon": day.symbol_code
                }
                result.append(daily_summary)
            
            return jsonify(result)
    
    @app.route("/api/weather/stats")
    @log_requests
    @handle_errors
    def weather_stats():
        """Get weather statistics for the last 24 hours"""
        
        with PerformanceLogger(logger, "weather_stats"):
            stats = weather_service.get_weather_statistics(24)
            
            if not stats:
                return jsonify({"error": "Unable to calculate statistics"}), 503
            
            return jsonify(stats.to_dict())
    
    # =================================================================
    # ENHANCED EXPORT ROUTES (using new export service)
    # =================================================================
    
    @app.route("/api/export/formats")
    @log_requests
    @handle_errors
    def export_formats():
        """Get available export formats"""
        formats = export_service.get_export_formats()
        return jsonify(formats)
    
    @app.route("/api/export/estimate")
    @log_requests
    @handle_errors
    def export_estimate():
        """Estimate export size and processing time"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({"error": "Missing start or end parameter"}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=request.args.get('format', 'csv')
            )
            
            estimate = export_service.estimate_export_size(config)
            return jsonify(estimate)
            
        except Exception as e:
            logger.error(f"Export estimation error: {e}")
            raise
    
    @app.route("/api/export/<format>")
    @log_requests
    @handle_errors
    def export_data(format: str):
        """Export data in specified format"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({"error": "Missing start or end parameter"}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=format,
                include_pond_data=request.args.get('include_pond', 'true').lower() == 'true',
                include_station_data=request.args.get('include_station', 'true').lower() == 'true',
                station_id=request.args.get('station_id'),
                limit=request.args.get('limit', type=int)
            )
            
            with PerformanceLogger(logger, "data_export", 
                                 format=format, start=start, end=end):
                
                exported_data = export_service.export_data(config)
                
                # Set appropriate content type and headers
                if format == 'csv':
                    response = app.response_class(
                        exported_data,
                        mimetype='text/csv',
                        headers={"Content-Disposition": f"attachment; filename=pond_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"}
                    )
                elif format == 'json':
                    response = app.response_class(
                        exported_data,
                        mimetype='application/json',
                        headers={"Content-Disposition": f"attachment; filename=pond_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"}
                    )
                elif format in ['excel', 'xlsx']:
                    response = app.response_class(
                        exported_data,
                        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                        headers={"Content-Disposition": f"attachment; filename=pond_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"}
                    )
                else:
                    return jsonify({"error": f"Unsupported format: {format}"}), 400
                
                return response
                
        except Exception as e:
            logger.error(f"Export error: {e}")
            raise


# Application factory
app = create_app()

if __name__ == "__main__":
    config = get_config()
    
    # Log startup information
    logger.info("Starting PondMonitor application")
    logger.info(f"Configuration summary: {config.get_summary()}")
    
    # Run application
    # In Docker containers, always use port 5000 internally
    # External port mapping is handled by docker-compose.yml
    import socket
    is_docker = os.path.exists('/.dockerenv')
    port = 5000 if is_docker else config.flask.port
    
    logger.info(f"Running Flask app on {'Docker' if is_docker else 'host'} port {port}")
    app.run(
        host=config.flask.host,
        port=port,
        debug=config.flask.debug
    )
