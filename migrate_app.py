"""
PondMonitor Migration Script - Week 1 Integration

This script helps integrate the new modular services into the existing app.py
while maintaining backward compatibility and ensuring smooth transition.

What it does:
1. Creates a new app_refactored.py with integrated services
2. Provides side-by-side comparison with original app.py
3. Handles service initialization and dependency injection
4. Maintains all existing API endpoints
5. Adds error handling and logging improvements

Usage:
    python migrate_app.py [--backup] [--test-mode]
"""

import os
import shutil
import argparse
from pathlib import Path
from datetime import datetime
from typing import Optional


MIGRATION_TEMPLATE = '''"""
PondMonitor Flask Application - Refactored Version

Migrated to use modular services for better maintainability and testability.
Generated by migrate_app.py on {timestamp}

Week 1 Refactoring Changes:
‚úÖ Centralized configuration management
‚úÖ Database service abstraction with connection pooling
‚úÖ Enhanced error handling and validation
‚úÖ Improved export service with multiple formats
‚úÖ Weather service with intelligent caching
‚úÖ Structured logging with request tracking
‚úÖ Comprehensive unit tests

Original functionality preserved with improved architecture.
"""

import os
import json
import logging
from datetime import datetime, timezone, timedelta
from flask import Flask, render_template, request, jsonify, g
from collections import defaultdict
from typing import Optional, Dict, Any, List

# Import our new modular services
from config import init_config, get_config
from database import init_database, get_database
from utils import handle_errors, log_requests, validate_json, Validator
from services.export_service import create_export_service, ExportConfig
from services.weather_service import create_weather_service
from logging_config import setup_logging, get_logger, PerformanceLogger

# Initialize logger
logger = get_logger(__name__)

# Global service instances
db_service = None
export_service = None
weather_service = None


def create_app(config_file: str = ".env") -> Flask:
    """
    Application factory with dependency injection.
    
    Args:
        config_file: Path to configuration file
    
    Returns:
        Configured Flask application
    """
    global db_service, export_service, weather_service
    
    # Initialize configuration
    logger.info("Initializing PondMonitor application")
    config = init_config(config_file)
    
    # Setup logging
    setup_logging(
        config.logging, 
        environment=config.flask.environment,
        enable_request_tracking=True
    )
    
    # Initialize Flask app
    app = Flask(__name__)
    app.config.update({{
        'SECRET_KEY': config.flask.secret_key,
        'TESTING': config.flask.testing,
        'DEBUG': config.flask.debug
    }})
    
    # Initialize services
    logger.info("Initializing services")
    
    try:
        # Database service
        db_service = init_database(config.database)
        logger.info("‚úÖ Database service initialized")
        
        # Export service
        export_service = create_export_service(db_service)
        logger.info("‚úÖ Export service initialized")
        
        # Weather service
        weather_service = create_weather_service(config.weather, config.redis)
        logger.info("‚úÖ Weather service initialized")
        
    except Exception as e:
        logger.error(f"Failed to initialize services: {{e}}")
        raise
    
    # Register error handlers
    register_error_handlers(app)
    
    # Register routes
    register_routes(app)
    
    logger.info("PondMonitor application initialized successfully")
    return app


def register_error_handlers(app: Flask) -> None:
    """Register global error handlers"""
    
    @app.errorhandler(500)
    def internal_server_error(error):
        logger.error(f"Internal server error: {{error}}")
        return jsonify({{"error": "Internal server error"}}), 500

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({{"error": "Resource not found"}}), 404


def register_routes(app: Flask) -> None:
    """Register all application routes"""
    
    # =================================================================
    # PAGE ROUTES (unchanged from original)
    # =================================================================
    
    @app.route("/")
    def dashboard():
        return render_template("dashboard.html")

    @app.route("/weather")
    def weather():
        return render_template("weather.html")

    @app.route("/diagnostics")
    def diagnostics():
        return render_template("diagnostics.html")
    
    # =================================================================
    # API ROUTES (enhanced with new services)
    # =================================================================
    
    @app.route("/health")
    @log_requests
    @handle_errors
    def health_check():
        """Enhanced health check with service status"""
        
        with PerformanceLogger(logger, "health_check"):
            status = {{
                "status": "healthy",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "services": {{}}
            }}
            
            # Check database service
            try:
                db_health = db_service.health_check()
                status["services"]["database"] = "healthy" if db_health.get("healthy") else "unhealthy"
            except Exception as e:
                logger.warning(f"Database health check failed: {{e}}")
                status["services"]["database"] = "unhealthy"
            
            # Check weather service
            try:
                weather_health = weather_service.health_check()
                status["services"]["weather_api"] = "healthy" if weather_health.get("healthy") else "degraded"
            except Exception as e:
                logger.warning(f"Weather health check failed: {{e}}")
                status["services"]["weather_api"] = "unhealthy"
            
            # Overall status
            unhealthy_services = [
                k for k, v in status["services"].items() 
                if v not in ["healthy", "degraded"]
            ]
            
            if unhealthy_services:
                status["status"] = "degraded"
                status["unhealthy_services"] = unhealthy_services
            
            return jsonify(status)
    
    @app.route("/api/status")
    @log_requests
    @handle_errors
    def get_status():
        """Get current sensor status from database"""
        
        with PerformanceLogger(logger, "get_status"):
            # Get latest metrics from database
            latest_metrics = db_service.get_latest_metrics()
            
            if not latest_metrics:
                return jsonify({{"error": "No data available"}}), 404
            
            # Calculate connection status
            now = datetime.now(timezone.utc)
            if 'station_timestamp' in latest_metrics:
                last_seen = latest_metrics['station_timestamp']
                if isinstance(last_seen, str):
                    last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00'))
                
                delta = now - last_seen
                connected = delta.total_seconds() < 120
                last_seen_minutes = int(delta.total_seconds() / 60)
            else:
                connected = False
                last_seen_minutes = 999
            
            # Build response
            response_data = {{
                "connected": connected,
                "last_seen_minutes": last_seen_minutes,
                "last_heartbeat": latest_metrics.get('station_timestamp', now.isoformat()),
                "temperature_c": latest_metrics.get('temperature_c'),
                "battery_v": latest_metrics.get('battery_v'),
                "solar_v": latest_metrics.get('solar_v'),
                "signal_dbm": latest_metrics.get('signal_dbm'),
                "on_solar": (latest_metrics.get('solar_v') or 0) > 1.0,
                "device_id": "POND-001",
                "firmware_version": "1.0.0"
            }}
            
            return jsonify(response_data)
    
    @app.route("/api/dashboard")
    @log_requests
    @handle_errors
    def api_dashboard():
        """Get dashboard data with enhanced validation"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            # Validate datetime range using new validator
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            with PerformanceLogger(logger, "dashboard_data_query", 
                                 start=start, end=end):
                
                # Get pond metrics
                pond_data = db_service.get_pond_metrics(start_dt, end_dt)
                
                # Transform to expected format (timestamp in milliseconds, value)
                level_data = []
                outflow_data = []
                
                for record in pond_data:
                    timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                    
                    if record['level_cm'] is not None:
                        level_data.append([timestamp_ms, record['level_cm']])
                    
                    if record['outflow_lps'] is not None:
                        outflow_data.append([timestamp_ms, record['outflow_lps']])
                
                return jsonify({{
                    "level": level_data,
                    "outflow": outflow_data,
                    "data_points": len(pond_data)
                }})
                
        except Exception as e:
            logger.error(f"Dashboard API error: {{e}}", exc_info=True)
            raise
    
    @app.route("/api/lora")
    @log_requests
    @handle_errors
    def diagnostics_data():
        """Get LoRa diagnostics data"""
        
        hours = request.args.get("hours", 24, type=int)
        
        # Validate hours parameter
        if not 1 <= hours <= 168:  # 1 hour to 1 week
            return jsonify({{"error": "Hours must be between 1 and 168"}}), 400
        
        start_time = datetime.now(timezone.utc) - timedelta(hours=hours)
        end_time = datetime.now(timezone.utc)
        
        with PerformanceLogger(logger, "lora_diagnostics_query", hours=hours):
            
            # Get station metrics
            station_data = db_service.get_station_metrics(start_time, end_time)
            
            # Transform to expected format
            temperature = []
            battery_voltage = []
            solar_voltage = []
            signal_strength = []
            
            for record in station_data:
                timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                
                if record['temperature_c'] is not None:
                    temperature.append([timestamp_ms, round(record['temperature_c'], 1)])
                
                if record['battery_v'] is not None:
                    battery_voltage.append([timestamp_ms, round(record['battery_v'], 2)])
                
                if record['solar_v'] is not None:
                    solar_voltage.append([timestamp_ms, round(record['solar_v'], 2)])
                
                if record['signal_dbm'] is not None:
                    signal_strength.append([timestamp_ms, record['signal_dbm']])
            
            return jsonify({{
                "temperature": temperature,
                "battery_voltage": battery_voltage,
                "solar_voltage": solar_voltage,
                "signal_strength": signal_strength,
                "data_points": len(station_data),
                "time_range_hours": hours
            }})
    
    # =================================================================
    # WEATHER API ROUTES (using new weather service)
    # =================================================================
    
    @app.route("/api/weather/current")
    @log_requests
    @handle_errors
    def weather_current():
        """Get current weather conditions"""
        
        with PerformanceLogger(logger, "weather_current"):
            current_weather = weather_service.get_current_weather()
            
            if not current_weather:
                return jsonify({{"error": "Weather service unavailable"}}), 503
            
            # Transform to expected format
            response = {{
                "timestamp": current_weather.timestamp,
                "temperature": current_weather.temperature,
                "pressure": current_weather.pressure,
                "humidity": current_weather.humidity,
                "wind": current_weather.wind_speed,
                "wind_direction": current_weather.wind_direction,
                "wind_gust": current_weather.wind_gust,
                "cloud_coverage": current_weather.cloud_coverage,
                "rain": current_weather.precipitation,
                "symbol_code": current_weather.symbol_code
            }}
            
            return jsonify(response)
    
    @app.route("/api/weather/meteogram")
    @log_requests
    @handle_errors
    def weather_meteogram():
        """Get 48-hour detailed forecast for meteogram"""
        
        with PerformanceLogger(logger, "weather_meteogram"):
            meteogram_data = weather_service.get_meteogram_data(48)
            
            # Transform to expected format
            result = []
            for weather in meteogram_data:
                weather_point = {{
                    "time": int(datetime.fromisoformat(weather.timestamp.replace("Z", "+00:00")).timestamp() * 1000),
                    "temperature": weather.temperature,
                    "rain": weather.precipitation,
                    "wind": weather.wind_speed,
                    "wind_direction": weather.wind_direction,
                    "wind_gust": weather.wind_gust,
                    "pressure": weather.pressure,
                    "humidity": weather.humidity,
                    "cloud": weather.cloud_coverage,
                    "symbol_code": weather.symbol_code
                }}
                result.append(weather_point)
            
            return jsonify(result)
    
    @app.route("/api/weather/daily")
    @log_requests
    @handle_errors
    def daily_forecast():
        """Get 7-day daily forecast summary"""
        
        with PerformanceLogger(logger, "weather_daily"):
            daily_data = weather_service.get_daily_forecast(7)
            
            # Transform to expected format
            result = []
            for day in daily_data:
                daily_summary = {{
                    "date": day.date,
                    "temp": day.temp_max,
                    "temp_min": day.temp_min,
                    "temp_avg": day.temp_avg,
                    "wind_avg": day.wind_avg,
                    "wind_gust": day.wind_gust,
                    "rain": day.precipitation,
                    "humidity_avg": day.humidity_avg,
                    "pressure_avg": day.pressure_avg,
                    "icon": day.symbol_code
                }}
                result.append(daily_summary)
            
            return jsonify(result)
    
    @app.route("/api/weather/stats")
    @log_requests
    @handle_errors
    def weather_stats():
        """Get weather statistics for the last 24 hours"""
        
        with PerformanceLogger(logger, "weather_stats"):
            stats = weather_service.get_weather_statistics(24)
            
            if not stats:
                return jsonify({{"error": "Unable to calculate statistics"}}), 503
            
            return jsonify(stats.to_dict())
    
    # =================================================================
    # ENHANCED EXPORT ROUTES (using new export service)
    # =================================================================
    
    @app.route("/api/export/formats")
    @log_requests
    @handle_errors
    def export_formats():
        """Get available export formats"""
        formats = export_service.get_export_formats()
        return jsonify(formats)
    
    @app.route("/api/export/estimate")
    @log_requests
    @handle_errors
    def export_estimate():
        """Estimate export size and processing time"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=request.args.get('format', 'csv')
            )
            
            estimate = export_service.estimate_export_size(config)
            return jsonify(estimate)
            
        except Exception as e:
            logger.error(f"Export estimation error: {{e}}")
            raise
    
    @app.route("/api/export/<format>")
    @log_requests
    @handle_errors
    def export_data(format: str):
        """Export data in specified format"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=format,
                include_pond_data=request.args.get('include_pond', 'true').lower() == 'true',
                include_station_data=request.args.get('include_station', 'true').lower() == 'true',
                station_id=request.args.get('station_id'),
                limit=request.args.get('limit', type=int)
            )
            
            with PerformanceLogger(logger, "data_export", 
                                 format=format, start=start, end=end):
                
                exported_data = export_service.export_data(config)
                
                # Set appropriate content type and headers
                if format == 'csv':
                    response = app.response_class(
                        exported_data,
                        mimetype='text/csv',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.csv"}}
                    )
                elif format == 'json':
                    response = app.response_class(
                        exported_data,
                        mimetype='application/json',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.json"}}
                    )
                elif format in ['excel', 'xlsx']:
                    response = app.response_class(
                        exported_data,
                        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.xlsx"}}
                    )
                else:
                    return jsonify({{"error": f"Unsupported format: {{format}}"}}), 400
                
                return response
                
        except Exception as e:
            logger.error(f"Export error: {{e}}")
            raise


# Application factory
app = create_app()

if __name__ == "__main__":
    config = get_config()
    
    # Log startup information
    logger.info("Starting PondMonitor application")
    logger.info(f"Configuration summary: {{config.get_summary()}}")
    
    # Run application
    app.run(
        host=config.flask.host,
        port=config.flask.port,
        debug=config.flask.debug
    )
'''


def create_backup(original_file: Path) -> Path:
    """Create a backup of the original file"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = original_file.with_suffix(f".backup_{timestamp}.py")
    shutil.copy2(original_file, backup_file)
    return backup_file


def create_refactored_app(original_app_path: Path, output_path: Path) -> None:
    """Create the refactored app.py file"""
    
    timestamp = datetime.now().isoformat()
    
    # Fill in the template
    refactored_content = MIGRATION_TEMPLATE.format(timestamp=timestamp)
    
    # Write the new file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(refactored_content)


def create_requirements_update() -> str:
    """Create updated requirements.txt with new dependencies"""
    
    additional_requirements = """
# Week 1 Refactoring - Additional Dependencies

# Enhanced data processing and export
pandas>=1.5.0
openpyxl>=3.1.0

# Testing framework
pytest>=7.0.0
pytest-cov>=4.0.0

# Code quality
black>=22.0.0
flake8>=5.0.0
mypy>=1.0.0

# Optional: Enhanced monitoring (for future weeks)
prometheus-client>=0.15.0
"""
    
    return additional_requirements


def create_docker_update() -> str:
    """Create Docker updates for new dependencies"""
    
    dockerfile_additions = """
# Week 1 Refactoring - Additional dependencies
# Add these to your existing Dockerfile requirements.txt installation

# For development/testing (optional)
# RUN pip install --no-cache-dir pytest pytest-cov black flake8 mypy

# For enhanced export functionality
# pandas and openpyxl are already in requirements.txt
"""
    
    return dockerfile_additions


def run_migration(args) -> None:
    """Run the migration process"""
    
    print("üöÄ PondMonitor Week 1 Migration Script")
    print("=" * 50)
    
    # Check for existing files
    original_app = Path("app.py")
    if not original_app.exists():
        print("‚ùå Original app.py not found in current directory")
        print("   Make sure you're running this from the PondMonitor root directory")
        return
    
    # Create backup if requested
    if args.backup:
        backup_file = create_backup(original_app)
        print(f"üì¶ Created backup: {backup_file}")
    
    # Create refactored version
    output_file = Path("app_refactored.py")
    create_refactored_app(original_app, output_file)
    print(f"‚ú® Created refactored app: {output_file}")
    
    # Create additional files
    requirements_update = create_requirements_update()
    with open("requirements_week1_additions.txt", "w") as f:
        f.write(requirements_update)
    print("üìã Created requirements_week1_additions.txt")
    
    docker_update = create_docker_update()
    with open("docker_week1_notes.txt", "w") as f:
        f.write(docker_update)
    print("üê≥ Created docker_week1_notes.txt")
    
    # Create test command helper
    test_commands = """#!/bin/bash
# Week 1 Testing Commands

echo "üß™ Running Week 1 Tests"

# Run unit tests
echo "Running unit tests..."
python -m pytest tests/ -v --cov=. --cov-report=html

# Test configuration
echo "Testing configuration..."
python -c "from config import init_config; config = init_config('.env.testing'); print('‚úÖ Configuration OK')"

# Test database connection (requires running containers)
echo "Testing database connection..."
python -c "
from config import init_config
from database import init_database
try:
    config = init_config('.env.testing')
    db = init_database(config.database)
    health = db.health_check()
    print(f'‚úÖ Database health: {health.get(\"healthy\", False)}')
except Exception as e:
    print(f'‚ö†Ô∏è Database test failed: {e}')
"

# Test weather service
echo "Testing weather service..."
python -c "
from config import init_config
from services.weather_service import create_weather_service
try:
    config = init_config('.env.testing')
    weather = create_weather_service(config.weather, config.redis)
    health = weather.health_check()
    print(f'‚úÖ Weather service health: {health.get(\"healthy\", False)}')
except Exception as e:
    print(f'‚ö†Ô∏è Weather test failed: {e}')
"

echo "‚úÖ All tests completed!"
"""
    
    with open("test_week1.sh", "w") as f:
        f.write(test_commands)
    os.chmod("test_week1.sh", 0o755)
    print("üß™ Created test_week1.sh")
    
    print("\nüéâ Migration completed successfully!")
    print("\nNext steps:")
    print("1. Review the generated files:")
    print(f"   - {output_file} (new refactored application)")
    print("   - requirements_week1_additions.txt (new dependencies)")
    print("   - test_week1.sh (testing script)")
    
    print("\n2. Install new dependencies:")
    print("   pip install pandas openpyxl pytest pytest-cov")
    
    print("\n3. Test the refactored application:")
    if args.test_mode:
        print("   Testing mode - Running basic validation...")
        test_configuration()
    else:
        print("   ./test_week1.sh")
    
    print("\n4. When ready, replace app.py:")
    print(f"   mv app.py app_original.py")
    print(f"   mv {output_file} app.py")
    
    print("\n‚ö†Ô∏è  Important notes:")
    print("   - Test thoroughly before deploying to production")
    print("   - Review all configuration settings in .env files")
    print("   - Monitor logs for any compatibility issues")
    print("   - The refactored app maintains API compatibility")


def test_configuration() -> None:
    """Test the basic configuration"""
    print("\nüß™ Testing configuration...")
    
    try:
        # Test import
        from config import create_test_config
        config = create_test_config()
        print("‚úÖ Configuration import successful")
        
        # Test validation
        config.validate()
        print("‚úÖ Configuration validation passed")
        
        # Test summary
        summary = config.get_summary()
        print(f"‚úÖ Configuration summary generated: {len(summary)} sections")
        
    except Exception as e:
        print(f"‚ùå Configuration test failed: {e}")
        print("   Make sure all new modules are in place")


def main():
    parser = argparse.ArgumentParser(
        description="Migrate PondMonitor to Week 1 refactored architecture"
    )
    parser.add_argument(
        "--backup", 
        action="store_true", 
        help="Create backup of original app.py"
    )
    parser.add_argument(
        "--test-mode", 
        action="store_true", 
        help="Run basic tests after migration"
    )
    
    args = parser.parse_args()
    
    try:
        run_migration(args)
    except Exception as e:
        print(f"‚ùå Migration failed: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()