"""
PondMonitor Migration Script - Week 1 Integration

This script helps integrate the new modular services into the existing app.py
while maintaining backward compatibility and ensuring smooth transition.

What it does:
1. Creates a new app_refactored.py with integrated services
2. Provides side-by-side comparison with original app.py
3. Handles service initialization and dependency injection
4. Maintains all existing API endpoints
5. Adds error handling and logging improvements

Usage:
    python migrate_app.py [--backup] [--test-mode]
"""

import os
import shutil
import argparse
from pathlib import Path
from datetime import datetime
from typing import Optional


MIGRATION_TEMPLATE = '''"""
PondMonitor Flask Application - Refactored Version

Migrated to use modular services for better maintainability and testability.
Generated by migrate_app.py on {timestamp}

Week 1 Refactoring Changes:
✅ Centralized configuration management
✅ Database service abstraction with connection pooling
✅ Enhanced error handling and validation
✅ Improved export service with multiple formats
✅ Weather service with intelligent caching
✅ Structured logging with request tracking
✅ Comprehensive unit tests

Original functionality preserved with improved architecture.
"""

import os
import json
import logging
from datetime import datetime, timezone, timedelta
from flask import Flask, render_template, request, jsonify, g
from collections import defaultdict
from typing import Optional, Dict, Any, List

# Import our new modular services
from config import init_config, get_config
from database import init_database, get_database
from utils import handle_errors, log_requests, validate_json, Validator
from services.export_service import create_export_service, ExportConfig
from services.weather_service import create_weather_service
from logging_config import setup_logging, get_logger, PerformanceLogger

# Initialize logger
logger = get_logger(__name__)

# Global service instances
db_service = None
export_service = None
weather_service = None


def create_app(config_file: str = ".env") -> Flask:
    """
    Application factory with dependency injection.
    
    Args:
        config_file: Path to configuration file
    
    Returns:
        Configured Flask application
    """
    global db_service, export_service, weather_service
    
    # Initialize configuration
    logger.info("Initializing PondMonitor application")
    config = init_config(config_file)
    
    # Setup logging
    setup_logging(
        config.logging, 
        environment=config.flask.environment,
        enable_request_tracking=True
    )
    
    # Initialize Flask app
    app = Flask(__name__)
    app.config.update({{
        'SECRET_KEY': config.flask.secret_key,
        'TESTING': config.flask.testing,
        'DEBUG': config.flask.debug
    }})
    
    # Initialize services
    logger.info("Initializing services")
    
    try:
        # Database service
        db_service = init_database(config.database)
        logger.info("✅ Database service initialized")
        
        # Export service
        export_service = create_export_service(db_service)
        logger.info("✅ Export service initialized")
        
        # Weather service
        weather_service = create_weather_service(config.weather, config.redis)
        logger.info("✅ Weather service initialized")
        
    except Exception as e:
        logger.error(f"Failed to initialize services: {{e}}")
        raise
    
    # Register error handlers
    register_error_handlers(app)
    
    # Register routes
    register_routes(app)
    
    logger.info("PondMonitor application initialized successfully")
    return app


def register_error_handlers(app: Flask) -> None:
    """Register global error handlers"""
    
    @app.errorhandler(500)
    def internal_server_error(error):
        logger.error(f"Internal server error: {{error}}")
        return jsonify({{"error": "Internal server error"}}), 500

    @app.errorhandler(404)
    def not_found_error(error):
        return jsonify({{"error": "Resource not found"}}), 404


def register_routes(app: Flask) -> None:
    """Register all application routes"""
    
    # =================================================================
    # PAGE ROUTES (unchanged from original)
    # =================================================================
    
    @app.route("/")
    def dashboard():
        return render_template("dashboard.html")

    @app.route("/weather")
    def weather():
        return render_template("weather.html")

    @app.route("/diagnostics")
    def diagnostics():
        return render_template("diagnostics.html")
    
    # =================================================================
    # API ROUTES (enhanced with new services)
    # =================================================================
    
    @app.route("/health")
    @log_requests
    @handle_errors
    def health_check():
        """Enhanced health check with service status"""
        
        with PerformanceLogger(logger, "health_check"):
            status = {{
                "status": "healthy",
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "services": {{}}
            }}
            
            # Check database service
            try:
                db_health = db_service.health_check()
                status["services"]["database"] = "healthy" if db_health.get("healthy") else "unhealthy"
            except Exception as e:
                logger.warning(f"Database health check failed: {{e}}")
                status["services"]["database"] = "unhealthy"
            
            # Check weather service
            try:
                weather_health = weather_service.health_check()
                status["services"]["weather_api"] = "healthy" if weather_health.get("healthy") else "degraded"
            except Exception as e:
                logger.warning(f"Weather health check failed: {{e}}")
                status["services"]["weather_api"] = "unhealthy"
            
            # Overall status
            unhealthy_services = [
                k for k, v in status["services"].items() 
                if v not in ["healthy", "degraded"]
            ]
            
            if unhealthy_services:
                status["status"] = "degraded"
                status["unhealthy_services"] = unhealthy_services
            
            return jsonify(status)
    
    @app.route("/api/status")
    @log_requests
    @handle_errors
    def get_status():
        """Get current sensor status from database"""
        
        with PerformanceLogger(logger, "get_status"):
            # Get latest metrics from database
            latest_metrics = db_service.get_latest_metrics()
            
            if not latest_metrics:
                return jsonify({{"error": "No data available"}}), 404
            
            # Calculate connection status
            now = datetime.now(timezone.utc)
            if 'station_timestamp' in latest_metrics:
                last_seen = latest_metrics['station_timestamp']
                if isinstance(last_seen, str):
                    last_seen = datetime.fromisoformat(last_seen.replace('Z', '+00:00'))
                
                delta = now - last_seen
                connected = delta.total_seconds() < 120
                last_seen_minutes = int(delta.total_seconds() / 60)
            else:
                connected = False
                last_seen_minutes = 999
            
            # Build response
            response_data = {{
                "connected": connected,
                "last_seen_minutes": last_seen_minutes,
                "last_heartbeat": latest_metrics.get('station_timestamp', now.isoformat()),
                "temperature_c": latest_metrics.get('temperature_c'),
                "battery_v": latest_metrics.get('battery_v'),
                "solar_v": latest_metrics.get('solar_v'),
                "signal_dbm": latest_metrics.get('signal_dbm'),
                "on_solar": (latest_metrics.get('solar_v') or 0) > 1.0,
                "device_id": "POND-001",
                "firmware_version": "1.0.0"
            }}
            
            return jsonify(response_data)
    
    @app.route("/api/dashboard")
    @log_requests
    @handle_errors
    def api_dashboard():
        """Get dashboard data with enhanced validation"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            # Validate datetime range using new validator
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            with PerformanceLogger(logger, "dashboard_data_query", 
                                 start=start, end=end):
                
                # Get pond metrics
                pond_data = db_service.get_pond_metrics(start_dt, end_dt)
                
                # Transform to expected format (timestamp in milliseconds, value)
                level_data = []
                outflow_data = []
                
                for record in pond_data:
                    timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                    
                    if record['level_cm'] is not None:
                        level_data.append([timestamp_ms, record['level_cm']])
                    
                    if record['outflow_lps'] is not None:
                        outflow_data.append([timestamp_ms, record['outflow_lps']])
                
                return jsonify({{
                    "level": level_data,
                    "outflow": outflow_data,
                    "data_points": len(pond_data)
                }})
                
        except Exception as e:
            logger.error(f"Dashboard API error: {{e}}", exc_info=True)
            raise
    
    @app.route("/api/lora")
    @log_requests
    @handle_errors
    def diagnostics_data():
        """Get LoRa diagnostics data"""
        
        hours = request.args.get("hours", 24, type=int)
        
        # Validate hours parameter
        if not 1 <= hours <= 168:  # 1 hour to 1 week
            return jsonify({{"error": "Hours must be between 1 and 168"}}), 400
        
        start_time = datetime.now(timezone.utc) - timedelta(hours=hours)
        end_time = datetime.now(timezone.utc)
        
        with PerformanceLogger(logger, "lora_diagnostics_query", hours=hours):
            
            # Get station metrics
            station_data = db_service.get_station_metrics(start_time, end_time)
            
            # Transform to expected format
            temperature = []
            battery_voltage = []
            solar_voltage = []
            signal_strength = []
            
            for record in station_data:
                timestamp_ms = int(record['timestamp'].timestamp() * 1000)
                
                if record['temperature_c'] is not None:
                    temperature.append([timestamp_ms, round(record['temperature_c'], 1)])
                
                if record['battery_v'] is not None:
                    battery_voltage.append([timestamp_ms, round(record['battery_v'], 2)])
                
                if record['solar_v'] is not None:
                    solar_voltage.append([timestamp_ms, round(record['solar_v'], 2)])
                
                if record['signal_dbm'] is not None:
                    signal_strength.append([timestamp_ms, record['signal_dbm']])
            
            return jsonify({{
                "temperature": temperature,
                "battery_voltage": battery_voltage,
                "solar_voltage": solar_voltage,
                "signal_strength": signal_strength,
                "data_points": len(station_data),
                "time_range_hours": hours
            }})
    
    # =================================================================
    # WEATHER API ROUTES (using new weather service)
    # =================================================================
    
    @app.route("/api/weather/current")
    @log_requests
    @handle_errors
    def weather_current():
        """Get current weather conditions"""
        
        with PerformanceLogger(logger, "weather_current"):
            current_weather = weather_service.get_current_weather()
            
            if not current_weather:
                return jsonify({{"error": "Weather service unavailable"}}), 503
            
            # Transform to expected format
            response = {{
                "timestamp": current_weather.timestamp,
                "temperature": current_weather.temperature,
                "pressure": current_weather.pressure,
                "humidity": current_weather.humidity,
                "wind": current_weather.wind_speed,
                "wind_direction": current_weather.wind_direction,
                "wind_gust": current_weather.wind_gust,
                "cloud_coverage": current_weather.cloud_coverage,
                "rain": current_weather.precipitation,
                "symbol_code": current_weather.symbol_code
            }}
            
            return jsonify(response)
    
    @app.route("/api/weather/meteogram")
    @log_requests
    @handle_errors
    def weather_meteogram():
        """Get 48-hour detailed forecast for meteogram"""
        
        with PerformanceLogger(logger, "weather_meteogram"):
            meteogram_data = weather_service.get_meteogram_data(48)
            
            # Transform to expected format
            result = []
            for weather in meteogram_data:
                weather_point = {{
                    "time": int(datetime.fromisoformat(weather.timestamp.replace("Z", "+00:00")).timestamp() * 1000),
                    "temperature": weather.temperature,
                    "rain": weather.precipitation,
                    "wind": weather.wind_speed,
                    "wind_direction": weather.wind_direction,
                    "wind_gust": weather.wind_gust,
                    "pressure": weather.pressure,
                    "humidity": weather.humidity,
                    "cloud": weather.cloud_coverage,
                    "symbol_code": weather.symbol_code
                }}
                result.append(weather_point)
            
            return jsonify(result)
    
    @app.route("/api/weather/daily")
    @log_requests
    @handle_errors
    def daily_forecast():
        """Get 7-day daily forecast summary"""
        
        with PerformanceLogger(logger, "weather_daily"):
            daily_data = weather_service.get_daily_forecast(7)
            
            # Transform to expected format
            result = []
            for day in daily_data:
                daily_summary = {{
                    "date": day.date,
                    "temp": day.temp_max,
                    "temp_min": day.temp_min,
                    "temp_avg": day.temp_avg,
                    "wind_avg": day.wind_avg,
                    "wind_gust": day.wind_gust,
                    "rain": day.precipitation,
                    "humidity_avg": day.humidity_avg,
                    "pressure_avg": day.pressure_avg,
                    "icon": day.symbol_code
                }}
                result.append(daily_summary)
            
            return jsonify(result)
    
    @app.route("/api/weather/stats")
    @log_requests
    @handle_errors
    def weather_stats():
        """Get weather statistics for the last 24 hours"""
        
        with PerformanceLogger(logger, "weather_stats"):
            stats = weather_service.get_weather_statistics(24)
            
            if not stats:
                return jsonify({{"error": "Unable to calculate statistics"}}), 503
            
            return jsonify(stats.to_dict())
    
    # =================================================================
    # ENHANCED EXPORT ROUTES (using new export service)
    # =================================================================
    
    @app.route("/api/export/formats")
    @log_requests
    @handle_errors
    def export_formats():
        """Get available export formats"""
        formats = export_service.get_export_formats()
        return jsonify(formats)
    
    @app.route("/api/export/estimate")
    @log_requests
    @handle_errors
    def export_estimate():
        """Estimate export size and processing time"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=request.args.get('format', 'csv')
            )
            
            estimate = export_service.estimate_export_size(config)
            return jsonify(estimate)
            
        except Exception as e:
            logger.error(f"Export estimation error: {{e}}")
            raise
    
    @app.route("/api/export/<format>")
    @log_requests
    @handle_errors
    def export_data(format: str):
        """Export data in specified format"""
        
        start = request.args.get("start")
        end = request.args.get("end")
        
        if not start or not end:
            return jsonify({{"error": "Missing start or end parameter"}}), 400
        
        try:
            start_dt, end_dt = Validator.validate_datetime_range(start, end)
            
            config = ExportConfig(
                start_time=start_dt,
                end_time=end_dt,
                format=format,
                include_pond_data=request.args.get('include_pond', 'true').lower() == 'true',
                include_station_data=request.args.get('include_station', 'true').lower() == 'true',
                station_id=request.args.get('station_id'),
                limit=request.args.get('limit', type=int)
            )
            
            with PerformanceLogger(logger, "data_export", 
                                 format=format, start=start, end=end):
                
                exported_data = export_service.export_data(config)
                
                # Set appropriate content type and headers
                if format == 'csv':
                    response = app.response_class(
                        exported_data,
                        mimetype='text/csv',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.csv"}}
                    )
                elif format == 'json':
                    response = app.response_class(
                        exported_data,
                        mimetype='application/json',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.json"}}
                    )
                elif format in ['excel', 'xlsx']:
                    response = app.response_class(
                        exported_data,
                        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                        headers={{"Content-Disposition": f"attachment; filename=pond_data_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}.xlsx"}}
                    )
                else:
                    return jsonify({{"error": f"Unsupported format: {{format}}"}}), 400
                
                return response
                
        except Exception as e:
            logger.error(f"Export error: {{e}}")
            raise


# Application factory
app = create_app()

if __name__ == "__main__":
    config = get_config()
    
    # Log startup information
    logger.info("Starting PondMonitor application")
    logger.info(f"Configuration summary: {{config.get_summary()}}")
    
    # Run application
    app.run(
        host=config.flask.host,
        port=config.flask.port,
        debug=config.flask.debug
    )
'''


def create_backup(original_file: Path) -> Path:
    """Create a backup of the original file"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_file = original_file.with_suffix(f".backup_{timestamp}.py")
    shutil.copy2(original_file, backup_file)
    return backup_file


def create_refactored_app(original_app_path: Path, output_path: Path) -> None:
    """Create the refactored app.py file"""
    
    timestamp = datetime.now().isoformat()
    
    # Fill in the template
    refactored_content = MIGRATION_TEMPLATE.format(timestamp=timestamp)
    
    # Write the new file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(refactored_content)


def create_requirements_update() -> str:
    """Create updated requirements.txt with new dependencies"""
    
    additional_requirements = """
# Week 1 Refactoring - Additional Dependencies

# Enhanced data processing and export
pandas>=1.5.0
openpyxl>=3.1.0

# Testing framework
pytest>=7.0.0
pytest-cov>=4.0.0

# Code quality
black>=22.0.0
flake8>=5.0.0
mypy>=1.0.0

# Optional: Enhanced monitoring (for future weeks)
prometheus-client>=0.15.0
"""
    
    return additional_requirements


def create_docker_update() -> str:
    """Create Docker updates for new dependencies"""
    
    dockerfile_additions = """
# Week 1 Refactoring - Additional dependencies
# Add these to your existing Dockerfile requirements.txt installation

# For development/testing (optional)
# RUN pip install --no-cache-dir pytest pytest-cov black flake8 mypy

# For enhanced export functionality
# pandas and openpyxl are already in requirements.txt
"""
    
    return dockerfile_additions


def run_migration(args) -> None:
    """Run the migration process"""
    
    print("🚀 PondMonitor Week 1 Migration Script")
    print("=" * 50)
    
    # Check for existing files
    original_app = Path("app.py")
    if not original_app.exists():
        print("❌ Original app.py not found in current directory")
        print("   Make sure you're running this from the PondMonitor root directory")
        return
    
    # Create backup if requested
    if args.backup:
        backup_file = create_backup(original_app)
        print(f"📦 Created backup: {backup_file}")
    
    # Create refactored version
    output_file = Path("app_refactored.py")
    create_refactored_app(original_app, output_file)
    print(f"✨ Created refactored app: {output_file}")
    
    # Create additional files
    requirements_update = create_requirements_update()
    with open("requirements_week1_additions.txt", "w") as f:
        f.write(requirements_update)
    print("📋 Created requirements_week1_additions.txt")
    
    docker_update = create_docker_update()
    with open("docker_week1_notes.txt", "w") as f:
        f.write(docker_update)
    print("🐳 Created docker_week1_notes.txt")
    
    # Create test command helper
    test_commands = """#!/bin/bash
# Week 1 Testing Commands

echo "🧪 Running Week 1 Tests"

# Run unit tests
echo "Running unit tests..."
python -m pytest tests/ -v --cov=. --cov-report=html

# Test configuration
echo "Testing configuration..."
python -c "from config import init_config; config = init_config('.env.testing'); print('✅ Configuration OK')"

# Test database connection (requires running containers)
echo "Testing database connection..."
python -c "
from config import init_config
from database import init_database
try:
    config = init_config('.env.testing')
    db = init_database(config.database)
    health = db.health_check()
    print(f'✅ Database health: {health.get(\"healthy\", False)}')
except Exception as e:
    print(f'⚠️ Database test failed: {e}')
"

# Test weather service
echo "Testing weather service..."
python -c "
from config import init_config
from services.weather_service import create_weather_service
try:
    config = init_config('.env.testing')
    weather = create_weather_service(config.weather, config.redis)
    health = weather.health_check()
    print(f'✅ Weather service health: {health.get(\"healthy\", False)}')
except Exception as e:
    print(f'⚠️ Weather test failed: {e}')
"

echo "✅ All tests completed!"
"""
    
    with open("test_week1.sh", "w") as f:
        f.write(test_commands)
    os.chmod("test_week1.sh", 0o755)
    print("🧪 Created test_week1.sh")
    
    print("\n🎉 Migration completed successfully!")
    print("\nNext steps:")
    print("1. Review the generated files:")
    print(f"   - {output_file} (new refactored application)")
    print("   - requirements_week1_additions.txt (new dependencies)")
    print("   - test_week1.sh (testing script)")
    
    print("\n2. Install new dependencies:")
    print("   pip install pandas openpyxl pytest pytest-cov")
    
    print("\n3. Test the refactored application:")
    if args.test_mode:
        print("   Testing mode - Running basic validation...")
        test_configuration()
    else:
        print("   ./test_week1.sh")
    
    print("\n4. When ready, replace app.py:")
    print(f"   mv app.py app_original.py")
    print(f"   mv {output_file} app.py")
    
    print("\n⚠️  Important notes:")
    print("   - Test thoroughly before deploying to production")
    print("   - Review all configuration settings in .env files")
    print("   - Monitor logs for any compatibility issues")
    print("   - The refactored app maintains API compatibility")


def test_configuration() -> None:
    """Test the basic configuration"""
    print("\n🧪 Testing configuration...")
    
    try:
        # Test import
        from config import create_test_config
        config = create_test_config()
        print("✅ Configuration import successful")
        
        # Test validation
        config.validate()
        print("✅ Configuration validation passed")
        
        # Test summary
        summary = config.get_summary()
        print(f"✅ Configuration summary generated: {len(summary)} sections")
        
    except Exception as e:
        print(f"❌ Configuration test failed: {e}")
        print("   Make sure all new modules are in place")


def main():
    parser = argparse.ArgumentParser(
        description="Migrate PondMonitor to Week 1 refactored architecture"
    )
    parser.add_argument(
        "--backup", 
        action="store_true", 
        help="Create backup of original app.py"
    )
    parser.add_argument(
        "--test-mode", 
        action="store_true", 
        help="Run basic tests after migration"
    )
    
    args = parser.parse_args()
    
    try:
        run_migration(args)
    except Exception as e:
        print(f"❌ Migration failed: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()